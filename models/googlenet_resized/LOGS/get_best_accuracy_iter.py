
import numpy as np
import csv
import argparse



def write_csv(output_filename, field_names, content, delimiter=','):
    """
        Write a CSV file
    """
    dialect = csv.excel
    dialect.delimiter = delimiter

    with open(output_filename, 'w') as f:
        '''
        dict_writer = csv.DictWriter(f, fieldnames=field_names,
                                     dialect=dialect)
        dict_writer.writeheader()

        dict_writer.writerows(content)'''

        dict_writer = csv.writer(f, dialect=dialect)
        dict_writer.writerow(field_names)
        dict_writer.writerows(content)


# labels, interest_fields = get_best_accuracy_iter.get_best_accuracy_iter('log.log.test', [1,12,11], 5448)
def get_best_accuracy_iter(parsed_log_file, sorted_xy_positions, snapshot):
    """
    That file allows you to find the best snaphot you have saved.

    log_file: path to the log file generated by '$CAFFE_ROOT/tools/extra/parse_log.py'
    sorted_xy_positions: list of the positions you are interested to extract (first the x-axes, then y-axes)
         e.g. my first row in the file generated by the precious script:
            [1] NumIters,Seconds,LearningRate,loss1/loss1,loss1/top-1,loss1/top-5,loss2/loss1,loss2/top-1,loss2/top-5,loss3/loss3,loss3/top-1,loss3/top-5
         I want to know wich snaphot has the best accuracy top-1 and then top-5, then my list will be:
            [11, 12]
    snapshot: parameter set in solver.prototxt
    """

    nline = 0
    labels = []
    interest_fields = []

    # make 0 the first element of a list. We supoose for the user is 1.
    sorted_xy_positions = np.array(sorted_xy_positions)-1

    # Open the file
    with open(parsed_log_file) as f:
        for line in f:
            nline += 1
            # Split the line by ',', delete the '\n' characters and transform to np.array to multiple acces
            line = np.array( [e.rstrip() for e in line.split(',')] )
            # first line is just for the labels
            if nline == 1:
                labels = line[sorted_xy_positions]
            else:
                # take the elements that we are interest on
                elems_current_iter = line[sorted_xy_positions]
                # make them float and transform the np.array to a list
                elems_current_iter = list( elems_current_iter.astype(np.float) )
                # save it on the list if caffe did a snaphot on that iteration
                if elems_current_iter[0]%snapshot==0:
                    interest_fields.append(elems_current_iter)

    # sort the list avoiding the iterations field in each tupla (the first)
    interest_fields.sort(key=lambda x: x[1:])
    # print all iterations
    print interest_fields
    # print the best ireation
    print 'best iteration: ', zip(labels,interest_fields[-1])
    # save the file in order to plot
    write_csv('acc_in_saved_iters', labels, interest_fields)


def parse_args():
    description = ('get Caffe saved iters log')

    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('parsed_log_file', metavar='f', help='Path to parsed log file')

    '''parser.add_argument('output_dir',
                        help='Directory in which to place output CSV files')'''

    parser.add_argument('sorted_xy_positions', metavar='N', type=int, nargs='+' , help='N 1 12 11, for x-axes:1 and y-axes:12 and 11 in that order')

    parser.add_argument('snaphot', metavar='s', type=int, help="the value of the parameter 'snapshot' specified in the file 'solver.prototxt'")

    args = parser.parse_args()
    return args


# python get_best_accuracy_iter.py  'log.log.test'  1 12 11 5448
# python get_best_accuracy_iter.py  f 'log.log.test'  N 1 12 11 s 5448
# python get_best_accuracy_iter.py  -f 'log.log.test'  -N 1 12 11 -s 5448
def main():
    args = parse_args()
    print 'file: ', args.parsed_log_file
    print 'x-axes in file: ', args.sorted_xy_positions[0]
    print 'sorted y-axes in file: ', args.sorted_xy_positions[1:]
    print 'snaphot: ', args.snaphot
    get_best_accuracy_iter(args.parsed_log_file, args.sorted_xy_positions, args.snaphot)



if __name__ == '__main__':
    main()
